using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Threading.Tasks;

namespace UnitTest.UnitTestHelpingTools
{
	public class Impression
	{
		public static ImpressionBuilder<T> Of<T>() where T : class
		{
			return new ImpressionBuilder<T>();
		}

		public class ImpressionBuilder<T> where T : class
		{
			private readonly Dictionary<string, object?> _memberValues = new();

			// Static, so we dont have to use reflection multiple time for samme T type
			private static readonly Dictionary<string, MemberInfo> _cachedMembers = new();

			static ImpressionBuilder()
			{
				var flags = BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic;

				// Gets all information in tpyeof(T). Such as Properties, Fields, Contructors, Methods
				MemberInfo[] allMemberInfo = typeof(T).GetMembers(flags);

				// Sets all Field and Property to the dict _cachedMembers for quicker lookup later
				_cachedMembers = allMemberInfo
										.Where(m =>
												(m.MemberType == MemberTypes.Field || m.MemberType == MemberTypes.Property)
												// BackingField is a autogenerated field foreach property, which we dont want to handle, so we exclude it from the beginning
												&& !m.Name.Contains("k__BackingField"))
										.ToDictionary(m => m.Name, m => m);
			}

			public ImpressionBuilder<T> With(string name, object? value)
			{
				// Checks if theres a MemberInfo with given Name
				if (!_cachedMembers.TryGetValue(name, out var memberInfo))
				{
					throw new ArgumentException($"No MemberInfo with that name exist for class of {typeof(T).Name}");
				}

				// Checks if the MemberInfo is of Property- or Fieldtype and then gets the datatype such as int, string...
				Type memberType = memberInfo switch
				{
					PropertyInfo prop => prop.PropertyType,
					FieldInfo field => field.FieldType,
				};

				/* Alternative
				 * if (memberInfo is PropertyInfo prop)
				 * {
				 *	  memberType = prop.PropertyType;
				 * }
				 */

				// If value is assigned a value (not null) and then checks which type value actually is AND then checks if the value can be assigned to memberType
				if (value != null && !memberType.IsAssignableFrom(value.GetType()!))
				{
					throw new ArgumentException($"Value of type {value.GetType()} was tried to be assigned to {memberInfo.GetType()}");
				}

				// Sets value to Dict. Later to be used when creating instance of t
				_memberValues[name] = value;

				return this;
			}

			public ImpressionBuilder<T> Randomize()
			{
				// Creates a instance of Random to 
				var random = new Random();

				// Iterates through each MemberInfo to set the value 
				foreach (var member in _cachedMembers.Values)
				{
					// If member is PropertyInfo then set Propertype else set FieldType.
					// No need for extra validation since all information in _cachedMembers is Properties or Fields
					var dataType = member is PropertyInfo p ? p.PropertyType : ((FieldInfo)member).FieldType;

					// If a Memberinfo is already set via With method then skip to next iteration
					if (_memberValues.ContainsKey(member.Name)) continue;

					// Sets the default value based on its type
					_memberValues[member.Name] = dataType switch
					{
						Type type when type == typeof(int) => random.Next(1, 10000),
						Type type when type == typeof(string) => $"Random_{Guid.NewGuid().ToString()}",
						Type type when type == typeof(bool) => random.Next(0, 2) == 0,
						Type type when type == typeof(DateTime) => DateTime.Now.AddDays(-random.Next(0, 365)),
						_ => SetDefault(dataType)
					};
					/*alternative
					 * if (dataType == typeof(string))
					 * {
					 *		_memberValues[member.Name] = $"Random_{Guid.NewGuid().ToString()}";
					 * }
					 */
				}
				return this;
			}

			private static object? SetDefault(Type t)
			{
				return t.IsValueType ? Activator.CreateInstance(t) : null;
			}

			public ImpressionBuilder<T> WithDefaults()
			{

				// Iterates through each MemberInfo to set the value 
				foreach (var member in _cachedMembers.Values)
				{
					// If member is PropertyInfo then set Propertype else set FieldType.
					// No need for extra validation since all information in _cachedMembers is Properties or Fields
					var dataType = member is PropertyInfo p ? p.PropertyType : ((FieldInfo)member).FieldType;

					// If a Memberinfo is already set via With method then skip to next iteration
					if (_memberValues.ContainsKey(member.Name)) continue;

					// Sets the default value based on its type
					_memberValues[member.Name] = SetDefault(dataType);
				}
				return this;
			}


			public T Create()
			{
				T instance = (T)Activator.CreateInstance(typeof(T), nonPublic: true)!;

				// Iterates through all objects sat via With Method
				foreach (var pair in _memberValues)
				{
					// Gets the object with the object name, such as Id or _iCustomerRepo
					var member = _cachedMembers[pair.Key];

					// if its a property then use PropertyInfos SetValue method to bypass private sets. If theres a property without a setmethod then dont set value otherwise it breaks
					if (member is PropertyInfo prop && prop.SetMethod != null)
					{
						prop.SetValue(instance, pair.Value);
					}
					// if its a property then use FieldInfos SetValue method to bypass private sets
					else if (member is FieldInfo field)
					{
						field.SetValue(instance, pair.Value);
					}
					// No need for else, since we have already made sure that only Properties and Fields are in _cachedMembers and therefore also _memberValues
				}

				// Object is now created with needed values and can be returned
				return instance;
			}


		}
	}
}
